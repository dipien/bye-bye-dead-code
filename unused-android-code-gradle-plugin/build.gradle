ext.PROJECT_NAME = "Unused Android Code Gradle Plugin"
ext.ARTIFACT_ID = "unused-android-code-gradle-plugin"
group = "com.jdroidtools"

apply plugin: "com.jdroidtools.gradle.plugin"
apply plugin: "com.gradle.plugin-publish"
apply plugin: 'groovy'

buildscript {
	dependencies {
		classpath(BuildLibs.JDROID_GRADLE_PROJECT_PLUGIN)
	}
}

dependencies {
	compile(Libs.JDROID_JAVA_CORE)
	implementation localGroovy()
	implementation 'org.jdom:jdom2:2.0.6'
	testCompile(Libs.JUNIT)
	testCompile(Libs.TRUTH)
}

gradlePlugin {
	plugins {
		unusedAndroidCodePlugin {
			id = "com.jdroidtools.unused-android-code"
			implementationClass = "com.jdroid.gradle.unusedandroidcode.UnusedAndroidCodePlugin"
		}
	}
}

pluginBundle {
	website = "https://jdroidtools.com/"
	vcsUrl = "https://github.com/maxirosson/unused-android-code-gradle-plugin"
	description = ext.PROJECT_NAME
	tags = ["gradle", "plugin", "android"]

	plugins {
		unusedAndroidCodePlugin {
			displayName = project.ext.PROJECT_NAME
		}
	}
}

// Remove this when groovy code is converted to Kotlin
tasks.named('compileGroovy') {
	// Groovy only needs the declared dependencies
	// and not the output of compileJava
	classpath = sourceSets.main.compileClasspath
}
tasks.named('compileKotlin') {
	// Kotlin also depends on the result of Groovy compilation
	// which automatically makes it depend of compileGroovy
	classpath += files(sourceSets.main.groovy.classesDirectory)
}
////////////////////////////////////////////////////////

jdroid {
	publishingPom = new Action<org.gradle.api.publish.maven.MavenPom>() {
		@Override
		public void execute(org.gradle.api.publish.maven.MavenPom mavenPom) {
			mavenPom.getName().set(project.ext.ARTIFACT_ID);
			mavenPom.getDescription().set(project.ext.PROJECT_NAME);

			mavenPom.getUrl().set("https://jdroidtools.com");
			mavenPom.getInceptionYear().set("2020");
			mavenPom.organization(new Action<MavenPomOrganization>() {
				@Override
				public void execute(MavenPomOrganization mavenPomOrganization) {
					mavenPomOrganization.getName().set("Jdroid Tools");
					mavenPomOrganization.getUrl().set("https://jdroidtools.com");
				}

			});
			mavenPom.licenses(new Action<MavenPomLicenseSpec>() {
				@Override
				public void execute(MavenPomLicenseSpec mavenPomLicenseSpec) {
					mavenPomLicenseSpec.license(new Action<MavenPomLicense>() {
						@Override
						public void execute(MavenPomLicense mavenPomLicense) {
							mavenPomLicense.getName().set("The Apache License, Version 2.0");
							mavenPomLicense.getUrl().set("http://www.apache.org/licenses/LICENSE-2.0.txt");
							mavenPomLicense.getDistribution().set("repo");
						}

					});
				}

			});
			mavenPom.developers(new Action<MavenPomDeveloperSpec>() {
				@Override
				public void execute(MavenPomDeveloperSpec mavenPomDeveloperSpec) {
					mavenPomDeveloperSpec.developer(new Action<MavenPomDeveloper>() {
						@Override
						public void execute(MavenPomDeveloper mavenPomDeveloper) {
							mavenPomDeveloper.getName().set("Maxi Rosson");
							mavenPomDeveloper.getEmail().set("maxi@jdroidtools.com");
						}

					});
				}

			});

			mavenPom.scm(new Action<MavenPomScm>() {
				@Override
				public void execute(MavenPomScm mavenPomScm) {
					mavenPomScm.getConnection().set("scm:git:" + jdroid.getRepositorySshUrl());
					mavenPomScm.getDeveloperConnection().set("scm:git:" + jdroid.getRepositorySshUrl());
					mavenPomScm.getUrl().set(jdroid.getRepositorySshUrl());
				}

			});
			mavenPom.issueManagement(new Action<MavenPomIssueManagement>() {
				@Override
				public void execute(MavenPomIssueManagement mavenPomIssueManagement) {
					mavenPomIssueManagement.getSystem().set("GitHub");
					mavenPomIssueManagement.getUrl().set(jdroid.getRepositoryUrl() + "/issues");
				}

			});

		}

	};
}
